"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4367],{28022:(n,e,t)=>{t.d(e,{A:()=>o});var r=t(54568),a=t(53706);t(7620);let o=n=>{let{content:e,onClick:t,className:o="",type:c="button",disabled:s=!1}=n;return(0,r.jsx)("button",{onClick:t,type:c,disabled:s,className:(0,a.cn)("px-4 py-2 font-secondary ring-1 ring-[var(--color-primary)] hover:ring-[var(--color-primary)] hover:text-[var(--color-primary)] bg-[var(--color-primary)] hover:bg-white transition-all ease-in-out duration-300 text-white disabled:ring-zinc-400 disabled:pointer-events-none disabled:text-[var(--color-secondary-400)] disabled:bg-[var(--color-secondary-300)] font-semibold cursor-pointer uppercase text-base -tracking-[0.04px] ",o),children:e})}},79242:(n,e,t)=>{t.d(e,{z4:()=>g});var r=t(24338);let a=r.env.NEXT_PUBLIC_SEARCH_URL||"",o=r.env.NEXT_PUBLIC_PARTSLOGIC_URL||"",c="fuelab"==r.env.NEXT_PUBLIC_TENANT_NAME?"aet":r.env.NEXT_PUBLIC_TENANT_NAME;async function s(n){let e;if(!a)throw Error("Missing NEXT_PUBLIC_SEARCH_URL");let t=n.startsWith("/")?n:"/".concat(n),r="".concat(a).concat(t);try{e=await fetch(r,{cache:"no-store",headers:{"Content-Type":"application/json"}})}catch(n){throw Error("GET ".concat(r," network error: ").concat(n instanceof Error?n.message:String(n)))}if(!e.ok){let n=e.statusText;try{let t=await e.json();n=(null==t?void 0:t.message)||n}catch(n){}throw Error("GET ".concat(r," failed: ").concat(e.status," ").concat(n))}return e.json()}async function i(n){let e;if(!o)throw Error("Missing NEXT_PUBLIC_PARTSLOGIC_URL");let t=n.startsWith("/")?n:"/".concat(n),r="".concat(o).concat(t);try{e=await fetch(r,{cache:"no-store",headers:{"Content-Type":"application/json",Accept:"application/json"}})}catch(n){throw Error("GET ".concat(r," network error: ").concat(n instanceof Error?n.message:String(n)))}if(!e.ok){let n=e.statusText;try{let t=await e.json();n=(null==t?void 0:t.message)||n}catch(n){}throw Error("GET ".concat(r," failed: ").concat(e.status," ").concat(n))}return e.json()}function l(n){let e=new URLSearchParams;return Object.entries(n).forEach(n=>{let[t,r]=n;void 0!==r&&""!==r&&e.set(t,String(r))}),e.toString()}async function u(n,e){var t,a;let o,c,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"graphql",i=function(n){if(!n)throw Error("NEXT_PUBLIC_API_URL is not configured");let e=n.trim();return/\/graphql\/?$/.test(e.toLowerCase())?e:e.replace(/\/+$/,"")+"/graphql"}(r.env.NEXT_PUBLIC_API_URL);try{o=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:n,variables:e})})}catch(t){let n=t instanceof Error?t.message:String(t);throw console.error("[".concat(s,"] network error"),n,{url:i,variables:e}),Error("".concat(s,": network error: ").concat(n))}let l=await o.text();if(!o.ok)throw console.error("[".concat(s,"] HTTP ").concat(o.status),l.slice(0,500)),Error("".concat(s,": HTTP ").concat(o.status));try{c=JSON.parse(l)}catch(n){throw console.error("[".concat(s,"] invalid JSON"),l.slice(0,500)),Error("".concat(s,": invalid JSON"))}let u=c;if(null==(t=u.errors)?void 0:t.length)throw console.error("[".concat(s,"] GraphQL errors"),u.errors),Error("".concat(s,": ").concat((null==(a=u.errors[0])?void 0:a.message)||"GraphQL error"));if(!u.data)throw console.error("[".concat(s,"] missing data"),c),Error("".concat(s,": invalid response (no data)"));return u.data}let d="\n  query GetAllCategories(\n    $channel: String!\n    $first: Int!\n    $after: String\n    $sortBy: CategorySortingInput\n  ) {\n    categories(\n      first: $first\n      after: $after\n      sortBy: $sortBy\n    ) {\n      totalCount\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      edges {\n        node {\n          id\n          name\n          slug\n          level\n          parent {\n            id\n            name\n          }\n          backgroundImage {\n            url\n            alt\n          }\n          products(channel: $channel) {\n            totalCount\n          }\n        }\n      }\n    }\n  }\n",g={getOrderById:async function(n){let{orderId:e}=n,t=await u("\n  query Order($id: ID!) {\n    order(id: $id) {\n      id\n      number\n      created\n      status\n      paymentStatus\n      total {\n        gross { amount currency }\n      }\n      lines {\n        id\n        productName\n        variantName\n        quantity\n        thumbnail { url }\n        totalPrice {\n          gross { amount currency }\n        }\n      }\n    }\n  }\n",{id:e},"order");if(!t.order)throw Error("Order not found");return t.order},getProductsByCategoriesAndProductTypes:async function(n){let{categoryIds:e,productTypeIds:t,channel:r,first:a,after:o,sortField:c="DATE",sortDirection:s="ASC"}=n,i={categoryIds:(null==e?void 0:e.length)?e:null,productTypeIds:(null==t?void 0:t.length)?t:null,channel:r,first:a,sortField:c,sortDirection:s};return o&&(i.after=o),await u("\n  query ProductsByCategoriesAndProductTypes(\n    $categoryIds: [ID!], \n    $productTypeIds: [ID!], \n    $channel: String!,\n    $first: Int!,\n    $after: String,\n    $sortField: ProductOrderField!,\n    $sortDirection: OrderDirection!\n  ) {\n    products(\n      filter: {\n        categories: $categoryIds\n        productTypes: $productTypeIds\n      }, \n      channel: $channel,\n      first: $first,\n      after: $after,\n      sortBy: {\n        field: $sortField,\n        direction: $sortDirection\n      }\n    ) {\n      totalCount\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        startCursor\n        endCursor\n      }\n      edges {\n        node {\n          id\n          name\n          slug\n          description\n          category {\n            id\n            name\n          }\n          productType {\n            id\n            name\n          }\n          media {\n            id\n            url\n            alt\n          }\n          pricing {\n            priceRange {\n              start {\n                gross {\n                  amount\n                  currency\n                }\n              }\n              stop {\n                gross {\n                  amount\n                  currency\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n",i,"products")},getGraphQLCategories:async function(n){let{channel:e,first:t=100,after:r}=n,a={channel:e,first:t,sortBy:{field:"PRODUCT_COUNT",direction:"DESC"}};return r&&(a.after=r),await u(d,a,"categories")},getCategoryBySlug:async function(n){var e;let{slug:t,channel:r}=n,a=null==(e=(await u("\n  query GetCategoryBySlug($slug: String!, $channel: String!) {\n    categories(first: 1, filter: { search: $slug }) {\n      edges {\n        node {\n          id\n          name\n          slug\n          level\n          parent {\n            id\n            name\n          }\n          backgroundImage {\n            url\n            alt\n          }\n          products(channel: $channel) {\n            totalCount\n          }\n        }\n      }\n    }\n  }\n",{slug:t,channel:r},"category")).categories.edges[0])?void 0:e.node;if(a&&a.slug===t)return a;let o=!0,c=null;for(;o;){let n={channel:r,first:100};c&&(n.after=c);let e=await u(d,n,"categories"),a=e.categories.edges.find(n=>n.node.slug===t);if(a)return a.node;o=e.categories.pageInfo.hasNextPage,c=e.categories.pageInfo.endCursor}return null},getGraphQLProductTypes:async function(n){let{first:e=100}=n;return await u('\n  query GetAllProductTypesWithCounts($first: Int!) {\n    productTypes(first: $first) {\n      totalCount\n      edges {\n        node {\n          id\n          name\n          slug\n          hasVariants\n          isShippingRequired\n          kind\n          metadata {\n            key\n            value\n          }\n          products(channel: "default-channel") {\n            totalCount\n          }\n        }\n      }\n    }\n  }\n',{first:e},"productTypes")},getProductsByCategory:async function(n){let{categoryIds:e,channel:t,first:r=100,after:a,search:o}=n,c={categoryIds:e,channel:t,first:r};return a&&(c.after=a),o&&o.trim()&&(c.search=o),await u("\n  query GetProductsByCategory(\n    $categoryIds: [ID!]\n    $channel: String!\n    $first: Int!\n    $after: String\n    $search: String\n  ) {\n    products(\n      filter: { \n        categories: $categoryIds\n      }\n      search: $search\n      channel: $channel\n      first: $first\n      after: $after\n    ) {\n      totalCount\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        endCursor\n        startCursor\n      }\n      edges {\n        cursor\n        node {\n          id\n          name\n          slug\n          description\n          category {\n            id\n            name\n          }\n          productType {\n            id\n            name\n          }\n          media {\n            id\n            url\n            alt\n          }\n          pricing {\n            priceRange {\n              start {\n                gross {\n                  amount\n                  currency\n                }\n              }\n              stop {\n                gross {\n                  amount\n                  currency\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n",c,"products")},getProductsByProductType:async function(n){let{productTypeIds:e,channel:t,first:r=100,after:a,search:o}=n,c={productTypeIds:e,channel:t,first:r};return a&&(c.after=a),o&&o.trim()&&(c.search=o),await u("\n  query GetProductsByProductType(\n    $productTypeIds: [ID!]\n    $channel: String!\n    $first: Int!\n    $after: String\n    $search: String\n  ) {\n    products(\n      filter: { \n        productTypes: $productTypeIds\n      }\n      search: $search\n      channel: $channel\n      first: $first\n      after: $after\n    ) {\n      totalCount\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        endCursor\n        startCursor\n      }\n      edges {\n        cursor\n        node {\n          id\n          name\n          slug\n          description\n          category {\n            id\n            name\n          }\n          productType {\n            id\n            name\n          }\n          media {\n            id\n            url\n            alt\n          }\n          pricing {\n            priceRange {\n              start {\n                gross {\n                  amount\n                  currency\n                }\n              }\n              stop {\n                gross {\n                  amount\n                  currency\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n",c,"products")},globalSearchStorefront:async function(n){let{query:e,channel:t="default-channel",includeProducts:r=!0,includeCategories:a=!0,includeCollections:o=!1,includeProductTypes:c=!0}=n;return await u("\n  query GlobalSearchStorefront(\n    $query: String!\n    $channel: String!\n    $includeProducts: Boolean!\n    $includeCategories: Boolean!\n    $includeCollections: Boolean!\n    $includeProductTypes: Boolean!\n  ) {\n    products(first: 10, channel: $channel, filter: { search: $query }) @include(if: $includeProducts) {\n      edges {\n        node {\n          id\n          name\n          slug\n          updatedAt\n          category {\n            id\n            name\n          }\n          thumbnail(size: 64) {\n            url\n            alt\n          }\n        }\n      }\n    }\n\n    categories(first: 10, filter: { search: $query }) @include(if: $includeCategories) {\n      edges {\n        node {\n          id\n          name\n          slug\n          level\n          parent {\n            id\n            name\n          }\n          backgroundImage(size: 64) {\n            url\n            alt\n          }\n          products(first: 1, channel: $channel) {\n            totalCount\n          }\n        }\n      }\n    }\n\n    collections(first: 10, channel: $channel, filter: { search: $query }) @include(if: $includeCollections) {\n      edges {\n        node {\n          id\n          name\n          slug\n          backgroundImage(size: 64) {\n            url\n            alt\n          }\n          products(first: 1) {\n            totalCount\n          }\n        }\n      }\n    }\n\n    productTypes(first: 10, filter: { search: $query }) @include(if: $includeProductTypes) {\n      edges {\n        node {\n          id\n          name\n          slug\n          hasVariants\n        }\n      }\n    }\n  }\n",{query:e,channel:t,includeProducts:r,includeCategories:a,includeCollections:o,includeProductTypes:c},"globalSearch")},async getCategories(){let n=l({tenant:c});return s("/search/api/categories?".concat(n))},async getBrands(){let n=l({tenant:c});return s("/search/api/brands?".concat(n))},async getYMMCombinations(){let n=l({tenant:c});return s("/search/api/ymm/combinations?".concat(n))},async getProductById(n){let e=l({tenant:c});return s("/search/api/products/".concat(n,"?").concat(e))},async searchProducts(){var n,e,t;let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=n=>Array.isArray(n)?n.join(","):n,o=l({q:null!=(n=r.q)?n:"*",tenant:c,category:a(r.category),brand:a(r.brand),years:a(r.years),makes:a(r.makes),models:a(r.models),per_page:null!=(e=r.per_page)?e:10,page:null!=(t=r.page)?t:1,sort:r.sort,in_stock:r.in_stock,min_price:r.min_price,max_price:r.max_price});return s("/search/api/search/multi-tenant?".concat(o))},pingYMM:async()=>i("/ping"),getYears:async()=>i("/api/search/fitments/years"),getRootTypes:async()=>i("/api/fitment-search/root-types"),getFitmentValuesId:async n=>i("/api/products/".concat(n,"/fitment-groups")),getFitmentValuesApi:async n=>i("/api/fitment-search/values/".concat(n)),getFitmentChildAPI:async n=>i("/api/fitment-search/child-types/".concat(n)),getMakes:async n=>i("/api/search/fitments/makes?year_id=".concat(n)),getModels:async(n,e)=>i("/api/search/fitments/models?year_id=".concat(n,"&make_id=").concat(e)),async searchProductsPL(n){var e,t;let r=l({q:n.q,fitment_pairs:n.fitment_pairs,page:null!=(e=n.page)?e:1,per_page:null!=(t=n.per_page)?t:20});return i("/api/search/products?".concat(r))},categoryProductPL:async()=>i("/api/categories?page=1&per_page=100"),brandsProductPL:async()=>i("/api/brands?page=1&per_page=100"),async getProductsBySlug(n){let{slug:e,page:t=1,per_page:r=20,search:a,filterType:o="category_slug"}=n,c=l({q:a||void 0,[o]:e,page:t,per_page:r});return i("/api/search/products?".concat(c))}}}}]);